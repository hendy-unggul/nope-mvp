<script>
// ==================== KONFIGURASI API ====================
// Ganti dengan URL yang benar (Vercel deployment atau local untuk development)
const API_URL = 'http://localhost:3000/api/chat'; // Untuk local development
// const API_URL = 'https://your-vercel-app.vercel.app/api/chat'; // Untuk production

// ==================== STATE ====================
let currentGender = null;
let chatPartner = null;
let timerInterval = null;
let chatTimeLeft = 900; // 15 menit
let selectedPlan = null;
let activeMood = 'all';
let radarInterval;
let radarRAF = null;
let userName = 'stranger_' + Math.floor(Math.random() * 1000);
let activeWsThread = null;
let vtBurnTimer = null;

// History chat untuk dikirim ke API
let chatHistory = [];

// Timer untuk fallback ke AI (60 detik)
let fallbackTimer = null;

// Flag untuk menandai API dalam mode offline
let apiOffline = false;

// Daftar karakter AI (hanya untuk referensi, logika ada di chat.js)
const AI_CHARACTERS = {
  female: ['beby.manis', 'strawberry.shortcake', 'pretty.sad', 'little.fairy', 'cinnamon.girl'],
  male: ['sejuta.badai', 'kue.bulan', 'agak.koplak', 'chili.padi', 'abang.gaul']
};

// Data void taps
let voidTaps = [
  { id: 'vt1', from: 'anonymous', content: 'ada yang pernah ngerasa jadi background character di hidup sendiri?', timestamp: Date.now() - 300000, read: false },
  { id: 'vt2', from: 'anonymous', content: 'kadang pengen ilang tanpa jejak, tapi takut ga ada yang nyari', timestamp: Date.now() - 600000, read: false }
];

// Data whisper
let whispers = [
  { id: 'w1', from: 'strawberry.shortcake', to: userName, content: 'halo, liat postingan kamu, relate banget', timestamp: Date.now() - 120000, read: false, thread: [] },
  { id: 'w2', from: 'sejuta.badai', to: userName, content: 'salam kenal, boleh ngobrol?', timestamp: Date.now() - 360000, read: true, thread: [] }
];

// Data spill (konten publik, bukan chat)
const USER_RANTS = [
  {id:1,author:'anon.kucing',mood:'surviving',content:'Hari ini gue nangis di angkot gegara liat kucing dipukul orang. Mental gue udah kayak kerupuk kena hujan.',reactions:{skull:42,cry:89,fire:12,upside:7},userReacted:null},
  {id:2,author:'sleepy.head',mood:'thriving',content:'akhirnya bisa tidur nyenyak semalaman setelah 3 minggu insomnia. makasih buat yang chat tadi malem.',reactions:{skull:23,cry:15,fire:67,upside:31},userReacted:null},
  {id:3,author:'chaos.queen',mood:'chaotic',content:'hari ini chaos abis! dari bangun tidur udah salah ambil kaki, sampe kantor lupa bawa laptop.',reactions:{skull:89,cry:23,fire:45,upside:78},userReacted:null},
  {id:4,author:'quiet.one',mood:'doom',content:'udah seminggu nggak keluar kamar. bukan karena sibuk. cuma nggak tau mau ngapain.',reactions:{skull:67,cry:112,fire:8,upside:34},userReacted:null}
];

const REACTION_EMOJI = {skull:'üíÄ',cry:'üò≠',fire:'üî•',upside:'üôÉ'};

// ==================== UTILS ====================
const $ = id => document.getElementById(id);
const esc = t => { const d = document.createElement('div'); d.textContent = t; return d.innerHTML; };

function toast(msg, isErr = false) {
  const t = $('toast');
  t.textContent = msg;
  t.className = 'toast' + (isErr ? ' error' : '');
  t.classList.add('show');
  setTimeout(() => t.classList.remove('show'), 2500);
}

function closeModal(id) {
  $(id).classList.remove('on');
}

function updateVibePct(val) {
  $('vibePct').textContent = val + '%';
}

function filterMood(btn) {
  document.querySelectorAll('.mood-chip').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
  activeMood = btn.dataset.mood;
  renderSpills();
}

// ==================== SPILLS (KONTEN PUBLIK) ====================
function generateSpillContent(count = 6) {
  // Ini untuk konten publik di halaman utama, BUKAN untuk chat
  const sampleSpills = [
    "hari ini gue liat mantan sama cewek baru, dan tau gak? rambutnya lebih bagus dari rambut gue üò≠",
    "cape bener jadi cewek, setiap bulan harus nahan sakit perut sambil tetep senyum di depan client",
    "kenapa sih cowok kalo ditanya 'lagi apa' pasti jawabnya 'lagi main'? ga ada variasi lain?",
    "gue lagi fase pengen dimengerti tanpa harus jelasin panjang lebar",
    "bete banget skincare gue habis, padahal baru kemarin beli. ada yang ngutil?",
    "hari ini gue salah kirim chat pacar ke grup keluarga. isinya 'sayang udah mandi belom?' üò≠",
    "kenapa orangtua selalu curiga kalo kita lagi seneng? 'lagi seneng-seneng ya? nanti belajar'",
    "gue lagi diet, tapi tiap liat roti, rotinya yang liat gue duluan",
    "stress skripsi tapi yang keluar peluh dan air mata doang",
    "hari ini gue nangis karena ga bisa buka toples. lemah?",
    "kadang gue mikir, apa kita yang terlalu berharap atau emang janjinya ga pernah ditepatin?",
    "hujan hari ini, tapi gaada yang tanya 'udah makan belom?'",
    "capek pura-pura baik-baik aja. gue juga manusia, bisa hancur",
    "kenapa ya orang lebih peduli sama 'kabar' daripada 'perasaan'?",
    "malam ini gue lagi fase nerima kenyataan kalo dia ga akan balik",
    "hari ini gue ditagih utang sama mantan. utang apa? utang perasaan katanya",
    "capek jadi orang yang dianggap kuat terus. gue juga pengen nangis dipeluk",
    "kenapa sih kalo udah malem suka overthinking? badan capek tapi pikiran lari maraton",
    "jadi cowok tuh gaboleh lemah katanya. tapi dalemnya ancur",
    "gue capek jadi 'tembok' tempat orang bersandar. giliran gue butuh sandaran, pada pergi"
  ];
  
  const moodList = ['surviving','thriving','chaotic','doom'];
  const nameList = ['anon.kucing','sleepy.head','chaos.queen','quiet.one','beby.manis','strawberry.shortcake','pretty.sad','little.fairy','cinnamon.girl','sejuta.badai','kue.bulan','agak.koplak','chili.padi','abang.gaul'];
  
  let result = [];
  let nextId = Math.max(...USER_RANTS.map(u => u.id), 5) + 1;
  
  for (let i = 0; i < count; i++) {
    result.push({
      id: nextId++,
      author: nameList[Math.floor(Math.random() * nameList.length)],
      isAI: Math.random() > 0.7,
      mood: moodList[Math.floor(Math.random() * moodList.length)],
      content: sampleSpills[Math.floor(Math.random() * sampleSpills.length)],
      reactions: { 
        skull: Math.floor(Math.random() * 50), 
        cry: Math.floor(Math.random() * 100), 
        fire: Math.floor(Math.random() * 40), 
        upside: Math.floor(Math.random() * 30) 
      },
      userReacted: null
    });
  }
  return result;
}

function renderSpills() {
  const list = $('spillsList');
  let allSpills = [...USER_RANTS, ...generateSpillContent(6)];
  let filtered = activeMood === 'all' ? allSpills : allSpills.filter(s => s.mood === activeMood);
  
  if (!filtered.length) {
    list.innerHTML = '<div class="empty-state"><div class="empty-icon">üçÉ</div><div class="empty-title">Belum ada spill</div><div class="empty-text">Coba filter lain</div></div>';
    return;
  }
  
  list.innerHTML = filtered.map(s => `
    <div class="spill-card">
      <div class="spill-head">
        <span class="spill-user">@${esc(s.author)}${s.isAI ? ' ü§ñ' : ''}</span>
        <span class="spill-mood ${s.mood}">${s.mood}</span>
      </div>
      <div class="spill-body">${esc(s.content)}</div>
      <div class="spill-actions">
        ${Object.entries(REACTION_EMOJI).map(([k, em]) => `
          <button class="react-btn ${s.userReacted === k ? 'active' : ''}" onclick="react(this, ${s.id}, '${k}')">
            ${em}<span class="react-count" id="rc-${s.id}-${k}">${s.reactions[k]}</span>
          </button>
        `).join('')}
      </div>
    </div>
  `).join('');
}

function react(btn, id, key) {
  let spill = [...USER_RANTS, ...generateSpillContent(0)].find(s => s.id === id);
  if (!spill) return;
  
  let wasActive = btn.classList.contains('active');
  document.querySelectorAll(`[id^="rc-${id}-"]`).forEach(el => el.closest('button').classList.remove('active'));
  
  if (wasActive) {
    spill.reactions[key]--;
  } else {
    spill.reactions[key]++;
    btn.classList.add('active');
  }
  
  spill.userReacted = wasActive ? null : key;
  
  Object.keys(spill.reactions).forEach(r => {
    let el = $(`rc-${id}-${r}`);
    if (el) el.textContent = spill.reactions[r];
  });
}

function refreshSpills() {
  renderSpills();
  toast('Teh baru diseduh ‚òï');
}

// ==================== RADAR ====================
let radarDots = [];
let needleAngle = 0;
let needleOmega = 0;
let phaseA = Math.random() * Math.PI * 2;
let phaseB = Math.random() * Math.PI * 2;
let phaseC = Math.random() * Math.PI * 2;
const BASE_RPM = 60 / 4;
const BASE_OMEGA = (BASE_RPM * Math.PI * 2) / (60 * 60);
const TRAIL_CAP = 120;
const trail = new Float32Array(TRAIL_CAP);
let trailPtr = 0;
const dotGlow = new Map();

function initRadar() {
  const canvas = $('radarCanvas');
  const container = $('radarCont');
  
  function resizeCanvas() {
    const rect = container.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
  }
  
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas, { passive: true });
  
  spawnDots();
  
  radarInterval = setInterval(() => {
    radarDots.forEach(d => {
      d.vx = (d.vx * 0.88) + (Math.random() - 0.5) * 0.3;
      d.vy = (d.vy * 0.88) + (Math.random() - 0.5) * 0.3;
      d.x = Math.max(9, Math.min(91, d.x + d.vx));
      d.y = Math.max(9, Math.min(91, d.y + d.vy));
      if (d.el) {
        d.el.style.left = d.x + '%';
        d.el.style.top = d.y + '%';
      }
    });
  }, 100);
  
  $('onlineCount').textContent = Math.floor(18 + Math.random() * 15) + ' ONLINE';
  needleAngle = Math.random() * Math.PI * 2;
  trail.fill(needleAngle);
  
  radarLoop(canvas);
}

function spawnDots() {
  const container = $('radarDots');
  if (!container) return;
  container.innerHTML = '';
  radarDots = [];
  
  let count = 5 + Math.floor(Math.random() * 5);
  for (let i = 0; i < count + 2; i++) {
    let isAI = i >= count;
    let angle = Math.random() * Math.PI * 2;
    let dist = 12 + Math.random() * 70;
    let x = 50 + Math.cos(angle) * dist / 2;
    let y = 50 + Math.sin(angle) * dist / 2;
    
    let dot = document.createElement('div');
    let type = isAI ? 'ai' : (Math.random() > 0.5 ? 'purple' : 'red');
    dot.className = 'radar-dot ' + type;
    dot.style.left = x + '%';
    dot.style.top = y + '%';
    container.appendChild(dot);
    
    radarDots.push({ el: dot, x, y, vx: 0, vy: 0, type, id: i });
  }
}

function radarLoop(canvas) {
  const ctx = canvas.getContext('2d');
  
  function draw(now) {
    if (!canvas || !ctx) return;
    
    const W = canvas.width;
    const H = canvas.height;
    const cx = W / 2;
    const cy = H / 2;
    const R = Math.min(cx, cy) * 0.88;
    
    phaseA += 0.007;
    phaseB += 0.013;
    phaseC += 0.041;
    
    const speedMult = 1.0 + Math.sin(phaseA) * 0.35 + Math.sin(phaseB) * 0.18 + Math.sin(phaseC) * 0.04;
    const targetOmega = BASE_OMEGA * speedMult;
    needleOmega += (targetOmega - needleOmega) * 0.028;
    needleAngle = (needleAngle + needleOmega) % (Math.PI * 2);
    
    trail[trailPtr] = needleAngle;
    trailPtr = (trailPtr + 1) % TRAIL_CAP;
    
    const fade = 0.09 + Math.sin(now * 0.0011) * 0.008;
    ctx.fillStyle = `rgba(1,5,1,${fade})`;
    ctx.fillRect(0, 0, W, H);
    
    // Draw trail
    for (let i = 0; i < TRAIL_CAP - 1; i++) {
      let newer = (trailPtr - 1 - i + TRAIL_CAP) % TRAIL_CAP;
      let older = (trailPtr - 2 - i + TRAIL_CAP) % TRAIL_CAP;
      let a0 = trail[older];
      let a1 = trail[newer];
      let recency = 1 - i / TRAIL_CAP;
      let alpha = Math.pow(recency, 1.6) * 0.52;
      
      if (alpha < 0.003) break;
      
      let start = a0;
      let end = a1;
      if (end - start > Math.PI) start += Math.PI * 2;
      if (start - end > Math.PI) end += Math.PI * 2;
      
      ctx.save();
      ctx.translate(cx, cy);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.arc(0, 0, R, start, end, false);
      ctx.closePath();
      ctx.fillStyle = `rgba(0,255,65,${alpha})`;
      ctx.fill();
      ctx.restore();
    }
    
    // Draw needle
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(needleAngle);
    ctx.shadowColor = 'rgba(0,255,65,0.9)';
    ctx.shadowBlur = 10;
    
    const lg = ctx.createLinearGradient(0, 0, R, 0);
    lg.addColorStop(0, 'rgba(0,255,65,1)');
    lg.addColorStop(0.55, 'rgba(0,255,65,0.8)');
    lg.addColorStop(0.85, 'rgba(0,255,65,0.35)');
    lg.addColorStop(1, 'rgba(0,255,65,0)');
    
    ctx.beginPath();
    ctx.moveTo(4, 0);
    ctx.lineTo(R, 0);
    ctx.strokeStyle = lg;
    ctx.lineWidth = 1.8;
    ctx.stroke();
    
    ctx.shadowBlur = 16;
    ctx.beginPath();
    ctx.arc(0, 0, 3.5, 0, Math.PI * 2);
    ctx.fillStyle = '#00ff41';
    ctx.fill();
    ctx.restore();
    
    // Draw glow on recently scanned dots
    radarDots.forEach((d, di) => {
      const px = d.x / 100 * W;
      const py = d.y / 100 * H;
      const dxp = px - cx;
      const dyp = py - cy;
      let dotAng = Math.atan2(dyp, dxp);
      if (dotAng < 0) dotAng += Math.PI * 2;
      
      let diff = needleAngle - dotAng;
      if (diff < 0) diff += Math.PI * 2;
      
      const age = dotGlow.get(di) ?? 999;
      
      if (diff < 0.14 && age > 40) {
        dotGlow.set(di, 0);
        if (d.el) {
          d.el.classList.add('active');
          setTimeout(() => { if (d.el) d.el.classList.remove('active'); }, 700);
        }
      } else {
        dotGlow.set(di, age + 1);
      }
      
      if (age < 60) {
        const t = age / 60;
        const ga = (1 - t) * (1 - t) * 0.9;
        if (ga > 0.01) {
          let col = d.type === 'purple' ? [176,38,255] : d.type === 'red' ? [255,0,64] : [0,255,65];
          const gr = ctx.createRadialGradient(px, py, 0, px, py, 14 * (1 - t) + 4);
          gr.addColorStop(0, `rgba(${col[0]},${col[1]},${col[2]},${ga})`);
          gr.addColorStop(1, `rgba(${col[0]},${col[1]},${col[2]},0)`);
          ctx.beginPath();
          ctx.arc(px, py, 14 * (1 - t) + 4, 0, Math.PI * 2);
          ctx.fillStyle = gr;
          ctx.fill();
        }
      }
    });
    
    radarRAF = requestAnimationFrame(draw);
  }
  
  radarRAF = requestAnimationFrame(draw);
}

function updateOnlineCount() {
  let el = $('onlineCount');
  if (el) {
    let count = Math.floor(Math.random() * 25) + 18;
    el.textContent = count + ' ONLINE';
  }
}

// ==================== VIBE CHECK - MURNI API CALL ====================
function startVibeCheck() {
  // Reset state
  chatPartner = null;
  chatTimeLeft = 900;
  chatHistory = [];
  
  if (fallbackTimer) {
    clearTimeout(fallbackTimer);
    fallbackTimer = null;
  }
  
  $('genderModal').classList.add('on');
}

function selectGender(el, gender) {
  document.querySelectorAll('.gender-card').forEach(c => c.classList.remove('selected'));
  el.classList.add('selected');
  currentGender = gender;
  $('confirmGenderBtn').disabled = false;
}

function confirmGender() {
  if (!currentGender) return;
  
  closeModal('genderModal');
  
  $('chatRoom').classList.add('on');
  $('chatTimer').textContent = '15:00';
  $('chatTimer').classList.remove('warn');
  
  const messages = $('chatMessages');
  messages.innerHTML = `
    <div class="chat-msg searching-msg">
      <div class="chat-bubble">üîç mencari real user dengan preferensi ${currentGender === 'female' ? 'cewek' : 'cowok'}...</div>
    </div>
  `;
  
  findRealUser();
  
  fallbackTimer = setTimeout(() => {
    if (!chatPartner && $('chatRoom').classList.contains('on')) {
      fallbackToAI();
    }
  }, 60000);
}

async function findRealUser() {
  // Simulasi pencarian real user - 5% chance dapet real user
  setTimeout(() => {
    if (!chatPartner && $('chatRoom').classList.contains('on')) {
      const hasRealUser = Math.random() < 0.05;
      
      if (hasRealUser) {
        if (fallbackTimer) {
          clearTimeout(fallbackTimer);
          fallbackTimer = null;
        }
        startRealChat();
      }
    }
  }, 3000);
}

function startRealChat() {
  // Untuk demo, fallback ke AI
  fallbackToAI();
}

function fallbackToAI() {
  if (fallbackTimer) {
    clearTimeout(fallbackTimer);
    fallbackTimer = null;
  }
  
  const gender = currentGender === 'female' ? 'female' : 'male';
  const charList = AI_CHARACTERS[gender];
  const randomChar = charList[Math.floor(Math.random() * charList.length)];
  
  chatPartner = {
    name: randomChar,
    isAI: true
  };
  
  const messages = $('chatMessages');
  messages.innerHTML = '';
  
  // Reset apiOffline flag untuk setiap sesi baru
  apiOffline = false;
  
  // Panggil API untuk first message
  callChatAPI('', true);
  
  startTimer();
}

function startTimer() {
  clearInterval(timerInterval);
  timerInterval = setInterval(updateTimer, 1000);
}

function updateTimer() {
  if (chatTimeLeft <= 0) {
    endChat();
    return;
  }
  
  chatTimeLeft--;
  const mins = Math.floor(chatTimeLeft / 60);
  const secs = chatTimeLeft % 60;
  $('chatTimer').textContent = `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  
  if (chatTimeLeft < 60) {
    $('chatTimer').classList.add('warn');
  }
}

function endChat() {
  clearInterval(timerInterval);
  addMsg('‚è∞ Waktu habis. Sesi vibe check selesai.', false);
  setTimeout(() => {
    closeChat();
    toast('Sesi vibe check selesai');
  }, 3000);
}

function closeChat() {
  $('chatRoom').classList.remove('on');
  clearInterval(timerInterval);
  
  if (fallbackTimer) {
    clearTimeout(fallbackTimer);
    fallbackTimer = null;
  }
}

// FUNGSI UTAMA: Call Chat API - DENGAN ERROR HANDLING YANG LEBIH BAIK
async function callChatAPI(userMessage, isFirstMessage = false) {
  if (!chatPartner || !chatPartner.isAI) return;
  
  // Jika API sudah terdeteksi offline, jangan coba-coba lagi
  if (apiOffline) {
    console.log('API is offline, skipping call');
    return;
  }
  
  // Tampilkan typing indicator
  const typingDiv = document.createElement('div');
  typingDiv.className = 'chat-msg other';
  typingDiv.innerHTML = '<div class="typing"><div class="typing-dot"></div><div class="typing-dot"></div><div class="typing-dot"></div></div>';
  $('chatMessages').appendChild(typingDiv);
  typingDiv.scrollIntoView({ behavior: 'smooth' });
  
  try {
    // Cek apakah API_URL valid
    if (!API_URL || API_URL === 'https://api.spill-app.com/chat') {
      throw new Error('API_URL not configured. Please set the correct API URL.');
    }
    
    const payload = {
      message: isFirstMessage ? '' : userMessage,
      characterName: chatPartner.name,
      userName: userName,
      lastMessages: chatHistory.slice(-8)
    };
    
    console.log('Calling API:', API_URL, payload);
    
    const response = await fetch(API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${API_KEY}`
      },
      body: JSON.stringify(payload)
    });
    
    typingDiv.remove();
    
    if (!response.ok) {
      throw new Error(`API error: ${response.status} ${response.statusText}`);
    }
    
    const data = await response.json();
    
    // Tampilkan reply dari API
    addMsg(data.reply, false);
    
    // Update history
    if (!isFirstMessage) {
      chatHistory.push({ role: 'user', content: userMessage });
    }
    chatHistory.push({ role: 'assistant', content: data.reply });
    
    // Handle distress signal
    if (data.distress) {
      const distressEl = $('distressMsg');
      distressEl.classList.add('show');
      if (data.distress === 'high') {
        distressEl.textContent = '‚ö†Ô∏è Perhatian: Partner menunjukkan tanda-tanda distress serius';
      } else if (data.distress === 'low') {
        distressEl.textContent = '‚ö†Ô∏è Partner terlihat sedih, respons dengan empati';
      }
    }
    
  } catch (error) {
    console.error('Error calling chat API:', error);
    typingDiv.remove();
    
    // Tandai API offline agar tidak terus mencoba
    apiOffline = true;
    
    // Tampilkan pesan error yang informatif ke user
    toast('Gagal terhubung ke server chat. Cek koneksi atau hubungi admin.', true);
    
    // Untuk first message, kita perlu kasih tahu user kalau AI tidak tersedia
    if (isFirstMessage) {
      addMsg('‚ö†Ô∏è Layanan chat sedang tidak tersedia. Silakan coba lagi nanti.', false);
      
      // Update history
      chatHistory.push({ role: 'assistant', content: '[system: service unavailable]' });
    }
    
    // Jika ini bukan first message, kita tidak perlu melakukan apa-apa
    // User sudah melihat error toast
  }
}

function sendMsg() {
  const input = $('chatInput');
  const text = input.value.trim();
  if (!text) return;
  
  addMsg(text, true);
  input.value = '';
  
  chatHistory.push({ role: 'user', content: text });
  
  if (chatPartner && chatPartner.isAI && !apiOffline) {
    callChatAPI(text);
  } else if (apiOffline) {
    toast('Server chat sedang offline', true);
  }
}

function addMsg(text, isOwn) {
  const messages = $('chatMessages');
  const msgDiv = document.createElement('div');
  msgDiv.className = 'chat-msg ' + (isOwn ? 'own' : 'other');
  
  const time = new Date().toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit' });
  
  msgDiv.innerHTML = `
    <div class="chat-bubble">${esc(text)}</div>
    <div class="chat-time">${time}</div>
  `;
  
  messages.appendChild(msgDiv);
  msgDiv.scrollIntoView({ behavior: 'smooth' });
}

// ==================== WHISPERER ====================
function openWsModal() {
  renderWsInbox();
  $('wsModal').classList.add('on');
}

function renderWsInbox() {
  const list = $('wsInboxList');
  if (!list) return;
  
  if (whispers.length === 0) {
    list.innerHTML = '<div class="ws-empty"><span class="ws-empty-icon">‚úß</span><div class="ws-empty-title">belum ada whisper</div><div class="ws-empty-sub">whisper akan muncul di sini</div></div>';
    return;
  }
  
  list.innerHTML = whispers.map(w => `
    <div class="ws-thread-item ${w.read ? '' : 'unread'}" onclick="openWsThread('${w.from}')">
      <div class="ws-avatar">${w.from.charAt(0)}</div>
      <div class="ws-thread-info">
        <div class="ws-thread-name">@${esc(w.from)}</div>
        <div class="ws-thread-preview">${esc(w.content)}</div>
      </div>
      <div class="ws-thread-right">
        <span class="ws-thread-time">${timeAgoShort(w.timestamp)}</span>
        ${!w.read ? '<span class="ws-unread-badge">new</span>' : ''}
      </div>
    </div>
  `).join('');
  
  updateWsBadge();
}

function timeAgoShort(timestamp) {
  const diff = Date.now() - timestamp;
  const mins = Math.floor(diff / 60000);
  if (mins < 60) return `${mins}m`;
  const hours = Math.floor(mins / 60);
  return `${hours}h`;
}

function updateWsBadge() {
  const unread = whispers.filter(w => !w.read).length;
  const badge = $('wsBadge');
  if (unread > 0) {
    badge.textContent = unread;
    badge.classList.add('show');
  } else {
    badge.classList.remove('show');
  }
}

function openWsCompose() {
  closeModal('wsModal');
  $('wsComposeScreen').classList.add('on');
  $('wsToInput').value = '';
  $('wsBodyInput').value = '';
  $('wsCharCount').textContent = '0/200';
  $('wsSendBtn').disabled = true;
}

function closeWsCompose() {
  $('wsComposeScreen').classList.remove('on');
}

function validateWsTo() {
  const to = $('wsToInput').value.trim();
  const body = $('wsBodyInput').value.trim();
  $('wsSendBtn').disabled = !(to && body);
}

function validateWsBody() {
  const body = $('wsBodyInput').value;
  $('wsCharCount').textContent = body.length + '/200';
  validateWsTo();
}

function sendWs() {
  const to = $('wsToInput').value.trim();
  const body = $('wsBodyInput').value.trim();
  if (!to || !body) return;
  
  whispers.push({
    id: 'w' + Date.now(),
    from: to,
    to: userName,
    content: body,
    timestamp: Date.now(),
    read: false,
    thread: []
  });
  
  toast('Whisper terkirim');
  closeWsCompose();
  openWsModal();
}

function openWsThread(username) {
  const whisper = whispers.find(w => w.from === username);
  if (!whisper) return;
  
  whisper.read = true;
  activeWsThread = whisper;
  
  $('wsThreadScreen').classList.add('on');
  $('wsThreadTitle').textContent = '@' + username;
  
  renderWsThread(whisper);
  updateWsBadge();
}

function closeWsThread() {
  $('wsThreadScreen').classList.remove('on');
  activeWsThread = null;
}

function renderWsThread(whisper) {
  const msgs = $('wsThreadMessages');
  
  let allMessages = [
    { from: whisper.from, content: whisper.content, timestamp: whisper.timestamp },
    ...whisper.thread
  ];
  
  msgs.innerHTML = allMessages.map(m => `
    <div class="chat-msg ${m.from === userName ? 'own' : 'other'}">
      <div class="chat-bubble">${esc(m.content)}</div>
      <div class="chat-time">${timeAgoShort(m.timestamp)}</div>
    </div>
  `).join('');
  
  msgs.scrollTop = msgs.scrollHeight;
}

function sendWsReply() {
  if (!activeWsThread) return;
  
  const input = $('wsThreadInput');
  const text = input.value.trim();
  if (!text) return;
  
  activeWsThread.thread.push({
    from: userName,
    content: text,
    timestamp: Date.now()
  });
  
  renderWsThread(activeWsThread);
  input.value = '';
}

// ==================== VOID TAP ====================
let vtQuota = 3;

function updateVtIndicator() {
  const indicator = $('vtIndicator').parentElement;
  if (voidTaps.filter(v => !v.read).length > 0) {
    indicator.classList.add('has-tap');
  } else {
    indicator.classList.remove('has-tap');
  }
}

function openVtCompose() {
  $('vtCompose').classList.add('on');
  $('vtTextarea').value = '';
  $('vtCharCount').textContent = '0/150';
  $('vtQuota').textContent = `sisa ${vtQuota}/3 hari ini`;
  $('vtSendBtn').disabled = vtQuota <= 0;
}

function closeVtCompose() {
  $('vtCompose').classList.remove('on');
}

function sendVoidTap() {
  if (vtQuota <= 0) {
    showVtUpgradeNudge();
    return;
  }
  
  const text = $('vtTextarea').value.trim();
  if (!text) return;
  
  vtQuota--;
  
  voidTaps.push({
    id: 'vt' + Date.now(),
    from: 'anonymous',
    content: text,
    timestamp: Date.now(),
    read: false
  });
  
  updateVtIndicator();
  toast('Void tap terkirim');
  closeVtCompose();
}

function checkVoidTaps() {
  const unread = voidTaps.filter(v => !v.read);
  if (unread.length === 0) {
    toast('Tidak ada void tap baru');
    return;
  }
  
  openVtReader(unread[0]);
}

function openVtReader(tap) {
  tap.read = true;
  updateVtIndicator();
  
  $('vtReader').classList.add('on');
  $('vtReaderFrom').textContent = `dari: @${tap.from}`;
  $('vtReaderMsg').textContent = tap.content;
  
  let timeLeft = 5;
  $('vtReaderTimer').textContent = `menghilang dalam ${timeLeft}s`;
  
  if (vtBurnTimer) clearInterval(vtBurnTimer);
  
  vtBurnTimer = setInterval(() => {
    timeLeft--;
    if (timeLeft <= 0) {
      clearInterval(vtBurnTimer);
      $('vtReader').classList.add('burning');
      setTimeout(() => {
        $('vtReader').classList.remove('on', 'burning');
      }, 700);
    } else {
      $('vtReaderTimer').textContent = `menghilang dalam ${timeLeft}s`;
    }
  }, 1000);
}

function showVtUpgradeNudge() {
  $('vtUpgradeNudge').classList.add('show');
  setTimeout(() => {
    $('vtUpgradeNudge').classList.remove('show');
  }, 3000);
}

function selectPlan(el, plan) {
  document.querySelectorAll('.price-card').forEach(c => c.classList.remove('selected'));
  el.classList.add('selected');
  selectedPlan = plan;
}

function upgradeNow() {
  if (!selectedPlan) {
    toast('Pilih paket dulu', true);
    return;
  }
  
  toast('Fitur premium diaktifkan (demo)');
  closeModal('upgradeModal');
  vtQuota = 999;
}

function showUpgradeModal() {
  $('upgradeModal').classList.add('on');
}

// ==================== INIT ====================
document.addEventListener('DOMContentLoaded', () => {
  initRadar();
  renderSpills();
  updateOnlineCount();
  updateWsBadge();
  updateVtIndicator();
  
  $('chatInput')?.addEventListener('keydown', e => { if (e.key === 'Enter') sendMsg(); });
  $('wsThreadInput')?.addEventListener('keydown', e => { if (e.key === 'Enter') sendWsReply(); });
  $('wsToInput')?.addEventListener('input', validateWsTo);
  $('wsBodyInput')?.addEventListener('input', validateWsBody);
  $('vtTextarea')?.addEventListener('input', function() {
    $('vtCharCount').textContent = this.value.length + '/150';
    $('vtSendBtn').disabled = this.value.trim().length === 0 || vtQuota <= 0;
  });
  
  window.addEventListener('beforeunload', () => {
    clearInterval(radarInterval);
    clearInterval(timerInterval);
    if (radarRAF) cancelAnimationFrame(radarRAF);
    if (fallbackTimer) clearTimeout(fallbackTimer);
  });
  
  setInterval(updateOnlineCount, 30000);
});
</script>
