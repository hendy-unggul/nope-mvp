    // ============================================
    // CORE FUNCTIONS (CONTINUED)
    // ============================================
    async function submitRant(content, mood) {
      const rantId = crypto.randomUUID();
      const timestamp = Date.now();
      
      const entry = {
        id: rantId,
        content: content,
        mood: mood,
        timestamp: timestamp,
        vibes: { relatable: 0, mood: 0, tea: 0, hug: 0, real: 0, dead: 0 },
        isSpilled: false,
        author: state.currentUser
      };

      // Save locally first
      addEntryFIFO(entry);
      
      // Try to sync with Supabase
      if (state.isOnline && state.supabase) {
        try {
          const { error } = await state.supabase
            .from('rants')
            .insert({
              id: rantId,
              content: content,
              mood: mood,
              author: state.currentUser,
              vibes: entry.vibes,
              created_at: new Date(timestamp).toISOString()
            });
          
          if (error) throw error;
          
          // Mark as spilled
          entry.isSpilled = true;
          updateEntry(rantId, { isSpilled: true });
          showToast('‚úì Spill synced to cloud');
        } catch (e) {
          console.error('Sync failed:', e);
          showToast('‚ö† Disimpan lokal, sync pending');
          queueForSync('rant', entry);
        }
      } else {
        showToast('‚ö† Disimpan lokal (offline)');
        queueForSync('rant', entry);
      }
      
      // Clear input
      document.getElementById('rant-input').value = '';
      document.getElementById('char-count').textContent = '0/500';
      selectMood('surviving');
    }

    function updateEntry(id, updates) {
      const idx = state.entries.findIndex(e => e.id === id);
      if (idx !== -1) {
        state.entries[idx] = { ...state.entries[idx], ...updates };
        saveEntries();
        renderEntries();
      }
    }

    function queueForSync(type, data) {
      const queue = JSON.parse(localStorage.getItem(STORAGE_PREFIX + 'sync_queue') || '[]');
      queue.push({ type, data, timestamp: Date.now() });
      localStorage.setItem(STORAGE_PREFIX + 'sync_queue', JSON.stringify(queue));
    }

    // ============================================
    // FACE API & IMAGE PROCESSING
    // ============================================
    async function loadFaceApiModels() {
      const MODEL_URL = 'https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.13/model/';
      try {
        await faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL);
        await faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL);
        state.faceApiLoaded = true;
        console.log('‚úì Face-API ready');
      } catch (e) {
        console.error('Face-API load failed:', e);
        state.faceApiLoaded = false;
      }
    }

    async function detectFaces(imageFile) {
      if (!state.faceApiLoaded) {
        console.warn('Face-API not loaded, skipping detection');
        return [];
      }
      
      document.getElementById('processing').classList.add('active');
      
      try {
        const img = await faceapi.bufferToImage(imageFile);
        const detections = await faceapi.detectAllFaces(img, new faceapi.TinyFaceDetectorOptions({ inputSize: CONFIG.inputSize, scoreThreshold: CONFIG.faceThreshold }));
        
        return detections.map(d => ({
          box: {
            x: d.box.x,
            y: d.box.y,
            width: d.box.width,
            height: d.box.height
          },
          score: d.score
        }));
      } catch (e) {
        console.error('Face detection error:', e);
        return [];
      } finally {
        document.getElementById('processing').classList.remove('active');
      }
    }

    function createFaceScribble(face, containerWidth, containerHeight) {
      const div = document.createElement('div');
      div.className = 'face-scribble';
      
      const scaleX = containerWidth / 416; // Based on inputSize
      const scaleY = containerHeight / (416 * (containerHeight/containerWidth));
      
      const x = face.box.x * scaleX;
      const y = face.box.y * scaleY;
      const w = face.box.width * scaleX;
      const h = face.box.height * scaleY;
      
      div.style.left = x + 'px';
      div.style.top = y + 'px';
      div.style.width = w + 'px';
      div.style.height = h + 'px';
      
      // Add marker lines effect
      const marker = document.createElement('div');
      marker.className = 'marker-lines';
      div.appendChild(marker);
      
      return div;
    }

    // ============================================
    // UPLOAD & GALLERY SYSTEM
    // ============================================
    function initUploadSystem() {
      const uploadBtn = document.getElementById('upload-btn');
      const fileInput = document.getElementById('file-input');
      
      uploadBtn.addEventListener('click', () => {
        if (!checkQuota()) {
          showToast('‚è≥ Quota habis. Tunggu window berikutnya.');
          return;
        }
        fileInput.click();
      });
      
      fileInput.addEventListener('change', handleFileSelect);
    }

    function checkQuota() {
      if (!state.quotaStart) {
        state.quotaStart = Date.now();
        localStorage.setItem(STORAGE_PREFIX + 'quota_start', state.quotaStart);
        state.uploadsThisWindow = 0;
        localStorage.setItem(STORAGE_PREFIX + 'uploads_count', '0');
        return true;
      }
      
      const elapsed = Date.now() - parseInt(state.quotaStart);
      const windowDuration = CONFIG.uploadWindowDays * 24 * 60 * 60 * 1000;
      
      if (elapsed > windowDuration) {
        // Reset window
        state.quotaStart = Date.now();
        state.uploadsThisWindow = 0;
        localStorage.setItem(STORAGE_PREFIX + 'quota_start', state.quotaStart);
        localStorage.setItem(STORAGE_PREFIX + 'uploads_count', '0');
        return true;
      }
      
      return state.uploadsThisWindow < CONFIG.maxSelection;
    }

    function updateQuotaDisplay() {
      const timer = document.getElementById('quota-timer');
      const counter = document.getElementById('upload-counter');
      
      if (!state.quotaStart) {
        timer.textContent = 'Window aktif ‚Ä¢ Sisa 6 slot';
        timer.classList.remove('urgent');
        counter.style.display = 'none';
        return;
      }
      
      const elapsed = Date.now() - parseInt(state.quotaStart);
      const windowDuration = CONFIG.uploadWindowDays * 24 * 60 * 60 * 1000;
      const remaining = Math.max(0, windowDuration - elapsed);
      const daysLeft = Math.ceil(remaining / (24 * 60 * 60 * 1000));
      const slotsLeft = CONFIG.maxSelection - state.uploadsThisWindow;
      
      if (remaining <= 0) {
        timer.textContent = 'Window reset ‚Ä¢ Sisa 6 slot';
        timer.classList.remove('urgent');
      } else {
        timer.textContent = `Window aktif ‚Ä¢ ${daysLeft} hari lagi ‚Ä¢ Sisa ${slotsLeft} slot`;
        if (slotsLeft <= 2) timer.classList.add('urgent');
      }
      
      if (state.uploadsThisWindow > 0) {
        counter.textContent = state.uploadsThisWindow;
        counter.style.display = 'block';
      } else {
        counter.style.display = 'none';
      }
    }

    async function handleFileSelect(e) {
      const files = Array.from(e.target.files);
      if (files.length === 0) return;
      
      // Check total size
      const totalSize = files.reduce((sum, f) => sum + f.size, 0);
      if (totalSize > CONFIG.maxFileSize * 2) {
        showToast('‚ö† Total file terlalu besar (max 10MB)');
        return;
      }
      
      // Process each file
      const processedFiles = [];
      for (const file of files.slice(0, CONFIG.maxSelection)) {
        const faces = await detectFaces(file);
        processedFiles.push({
          file: file,
          faces: faces,
          hasFace: faces.length > 0,
          preview: URL.createObjectURL(file)
        });
      }
      
      openGallery(processedFiles);
    }

    function openGallery(files) {
      state.selectedFiles = new Set(files.map((_, i) => i));
      state.currentTheme = 0;
      state.notationText = '';
      
      const grid = document.getElementById('gallery-grid');
      grid.innerHTML = '';
      
      files.forEach((item, idx) => {
        const div = document.createElement('div');
        div.className = 'gallery-item' + (state.selectedFiles.has(idx) ? ' selected' : '');
        div.innerHTML = `<img src="${item.preview}" alt="preview" class="filter-monochrome" id="preview-${idx}">`;
        div.onclick = () => toggleSelection(idx, div);
        
        if (item.hasFace) {
          const badge = document.createElement('div');
          badge.className = 'detection-badge';
          badge.textContent = 'WAJAH TERDETEKSI';
          div.appendChild(badge);
        }
        
        grid.appendChild(div);
      });
      
      // Reset theme slider and notation
      document.getElementById('theme-slider').value = 0;
      document.getElementById('theme-name').textContent = THEMES[0].name;
      document.getElementById('notation-input').value = '';
      document.getElementById('notation-count').textContent = '0/4';
      updateSelectedCount();
      
      document.getElementById('gallery-modal').classList.add('active');
      
      // Store files for later
      state.pendingFiles = files;
    }

    function toggleSelection(idx, element) {
      if (state.selectedFiles.has(idx)) {
        state.selectedFiles.delete(idx);
        element.classList.remove('selected');
      } else {
        state.selectedFiles.add(idx);
        element.classList.add('selected');
      }
      updateSelectedCount();
    }

    function updateSelectedCount() {
      document.getElementById('selected-count').textContent = state.selectedFiles.size;
    }

    function updateThemeFromSlider(value) {
      state.currentTheme = parseInt(value);
      const theme = THEMES[state.currentTheme];
      document.getElementById('theme-name').textContent = theme.name;
      
      // Update all previews
      state.pendingFiles.forEach((_, idx) => {
        const img = document.getElementById(`preview-${idx}`);
        if (img) {
          // Remove all filter classes
          img.className = '';
          // Add new filter
          img.classList.add(theme.filter);
        }
      });
    }

    function validateNotation(input) {
      const words = input.value.trim().split(/\s+/).filter(w => w.length > 0);
      const count = words.length;
      document.getElementById('notation-count').textContent = `${count}/4`;
      
      if (count > 4) {
        input.value = words.slice(0, 4).join(' ');
        document.getElementById('notation-count').textContent = '4/4';
      }
      
      state.notationText = input.value.trim();
    }

    function closeGallery() {
      document.getElementById('gallery-modal').classList.remove('active');
      state.pendingFiles = [];
      state.selectedFiles = new Set();
    }

    async function confirmUpload() {
      if (state.selectedFiles.size === 0) {
        showToast('Pilih minimal 1 foto');
        return;
      }
      
      const theme = THEMES[state.currentTheme];
      const notation = state.notationText || 'memory';
      
      // Process selected files
      for (const idx of state.selectedFiles) {
        const item = state.pendingFiles[idx];
        await processAndUploadArtefact(item, theme, notation);
      }
      
      // Update quota
      state.uploadsThisWindow += state.selectedFiles.size;
      localStorage.setItem(STORAGE_PREFIX + 'uploads_count', state.uploadsThisWindow.toString());
      updateQuotaDisplay();
      
      closeGallery();
      showToast(`‚úì ${state.selectedFiles.size} foto diupload`);
    }

    async function processAndUploadArtefact(item, theme, notation) {
      const artefactId = crypto.randomUUID();
      
      // Create canvas for processing
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const img = new Image();
      
      await new Promise((resolve) => {
        img.onload = resolve;
        img.src = item.preview;
      });
      
      canvas.width = img.width;
      canvas.height = img.height;
      
      // Apply filter via CSS-like canvas operations
      ctx.filter = getCanvasFilter(theme.filter);
      ctx.drawImage(img, 0, 0);
      
      // Convert to blob
      const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.85));
      
      // Upload to Supabase Storage if online
      let publicUrl = item.preview; // fallback
      
      if (state.isOnline && state.supabase) {
        try {
          const fileName = `${state.currentUser}/${artefactId}.jpg`;
          const { error: uploadError } = await state.supabase
            .storage
            .from(CONFIG.storageBucket)
            .upload(fileName, blob);
          
          if (uploadError) throw uploadError;
          
          const { data: { publicUrl: url } } = state.supabase
            .storage
            .from(CONFIG.storageBucket)
            .getPublicUrl(fileName);
          
          publicUrl = url;
          
          // Save metadata to DB
          await state.supabase.from('artefacts').insert({
            id: artefactId,
            url: publicUrl,
            note: notation,
            faces: item.faces,
            has_face: item.hasFace,
            author: state.currentUser,
            theme: theme.name,
            created_at: new Date().toISOString()
          });
          
        } catch (e) {
          console.error('Upload failed:', e);
          // Save locally for later sync
        }
      }
      
      // Add to local state
      const artefact = {
        id: artefactId,
        url: publicUrl,
        note: notation,
        faces: item.faces,
        hasFace: item.hasFace,
        theme: theme.name,
        timestamp: Date.now(),
        isDummy: false
      };
      
      addArtefactFIFO(artefact);
      
      // Set as hero if first
      if (state.artefacts.filter(a => !a.isDummy).length === 1) {
        setHero(publicUrl, notation, item.faces, theme.filter);
      }
    }

    function getCanvasFilter(filterClass) {
      const filters = {
        'filter-monochrome': 'grayscale(100%) contrast(1.1)',
        'filter-noir': 'grayscale(100%) contrast(1.4) brightness(0.8)',
        'filter-sepia': 'sepia(100%) contrast(1.1) saturate(0.8)',
        'filter-warm': 'sepia(60%) hue-rotate(-30deg) saturate(1.2)',
        'filter-golden': 'sepia(40%) hue-rotate(-15deg) saturate(1.3) contrast(1.1)',
        'filter-lomo': 'contrast(1.2) saturate(1.3) brightness(0.9)',
        'filter-dream': 'blur(0.5px) saturate(1.4) brightness(1.1) contrast(0.9)',
        'filter-cold': 'hue-rotate(180deg) saturate(0.5) brightness(1.1)',
        'filter-cyber': 'hue-rotate(180deg) saturate(1.5) contrast(1.1)',
        'filter-vignette': 'grayscale(100%) contrast(1.2) brightness(0.9)',
        'filter-crisp': 'contrast(1.3) saturate(1.1)',
        'filter-moody': 'brightness(0.8) contrast(1.2) saturate(0.7)'
      };
      return filters[filterClass] || filters['filter-monochrome'];
    }

    // ============================================
    // RENDERING
    // ============================================
    function renderEntries() {
      const container = document.getElementById('entries-container');
      const entries = getVisibleEntries();
      
      if (entries.length === 0) {
        container.innerHTML = `
          <div class="empty-state">
            <span class="empty-emoji">üçÉ</span>
            <div class="empty-text">Belum ada jejak</div>
            <div class="empty-subtext">Jadilah yang pertama spill your truth</div>
          </div>
        `;
        return;
      }
      
      container.innerHTML = entries.map(entry => {
        const mood = MOODS[entry.mood];
        const date = new Date(entry.timestamp);
        const timeStr = date.toLocaleDateString('id-ID', { day: 'numeric', month: 'short' }) + ' ‚Ä¢ ' + 
                       date.toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit' });
        
        const isDummy = entry.isDummy || entry.id.startsWith('__d');
        
        return `
          <article class="entry ${isDummy ? 'entry-dummy' : ''}" data-id="${entry.id}">
            <div class="entry-header">
              <div class="entry-meta">
                <span class="entry-time">${timeStr}</span>
                <span class="entry-mood ${entry.mood}">${mood.emoji} ${mood.label}</span>
              </div>
              ${isDummy ? '<span class="fifo-indicator">Contoh</span>' : ''}
            </div>
            <div class="entry-content">${escapeHtml(entry.content)}</div>
            <div class="spill-status ${entry.isSpilled ? 'spilled' : ''}">
              ${entry.isSpilled ? '‚úì Synced to cloud' : '‚è≥ Pending sync'}
            </div>
            <div class="vibe-bar">
              ${Object.entries(VIBES).map(([key, vibe]) => `
                <button class="vibe-btn ${(entry.vibes?.[key] > 0) ? 'vibed' : ''}" onclick="addVibe('${entry.id}', '${key}')" ${isDummy ? 'disabled' : ''}>
                  <span class="vibe-emoji">${vibe.emoji}</span>
                  <span class="vibe-count">${entry.vibes?.[key] || 0}</span>
                  <span class="vibe-label">${vibe.label}</span>
                </button>
              `).join('')}
            </div>
          </article>
        `;
      }).join('');
    }

    function renderTray() {
      const grid = document.getElementById('tray-grid');
      const artefacts = getVisibleArtefacts();
      
      grid.innerHTML = artefacts.map((art, idx) => {
        const isDummy = art.isDummy || art.id.startsWith('__a');
        
        if (!art.url) {
          return `<div class="tray-item empty">+</div>`;
        }
        
        return `
          <div class="tray-item ${isDummy ? 'tray-item-dummy' : ''}" onclick="setHeroFromTray('${art.id}')" style="position:relative">
            <img src="${art.url}" alt="${art.note}" class="${art.theme ? 'filter-' + art.theme.toLowerCase() : 'filter-monochrome'}">
            ${art.hasFace ? '<span class="detection-badge">SENSORED</span>' : ''}
          </div>
        `;
      }).join('');
    }

    function setHero(url, note, faces, filterClass = 'filter-monochrome') {
      const heroImg = document.getElementById('hero-img');
      const heroNotation = document.getElementById('hero-notation');
      const heroFaces = document.getElementById('hero-faces');
      
      heroImg.src = url;
      heroImg.className = filterClass;
      heroNotation.textContent = `"${note}"`;
      
      // Clear and redraw face scribbles
      heroFaces.innerHTML = '';
      if (faces && faces.length > 0) {
        faces.forEach(face => {
          const scribble = createFaceScribble(face, heroImg.clientWidth, heroImg.clientHeight);
          heroFaces.appendChild(scribble);
        });
      }
    }

    function setHeroFromTray(id) {
      const art = state.artefacts.find(a => a.id === id) || DUMMY_ARTEFACTS.find(a => a.id === id);
      if (art) {
        setHero(art.url, art.note, art.faces, art.theme ? 'filter-' + art.theme.toLowerCase() : 'filter-monochrome');
      }
    }

    // ============================================
    // INTERACTIONS
    // ============================================
    function selectMood(mood) {
      state.currentMood = mood;
      document.querySelectorAll('.mood-card').forEach(card => {
        card.classList.toggle('active', card.dataset.mood === mood);
      });
    }

    async function addVibe(entryId, vibeType) {
      if (state.userVibes.has(entryId + '-' + vibeType)) {
        showToast('Kamu sudah memberi vibe ini');
        return;
      }
      
      state.userVibes.add(entryId + '-' + vibeType);
      
      const entry = state.entries.find(e => e.id === entryId);
      if (!entry) return;
      
      entry.vibes[vibeType] = (entry.vibes[vibeType] || 0) + 1;
      updateEntry(entryId, { vibes: entry.vibes });
      
      // Sync to DB if online
      if (state.isOnline && state.supabase && !entryId.startsWith('__')) {
        try {
          await state.supabase
            .from('rants')
            .update({ vibes: entry.vibes })
            .eq('id', entryId);
        } catch (e) {
          console.error('Vibe sync failed:', e);
        }
      }
      
      showToast(`+1 ${VIBES[vibeType].label}`);
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function showToast(message) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 3000);
    }

    // ============================================
    // STORAGE HELPERS
    // ============================================
    function saveEntries() {
      localStorage.setItem(STORAGE_PREFIX + 'entries', JSON.stringify(state.entries));
    }

    function saveArtefacts() {
      localStorage.setItem(STORAGE_PREFIX + 'artefacts', JSON.stringify(state.artefacts));
    }

    function loadFromStorage() {
      const entries = localStorage.getItem(STORAGE_PREFIX + 'entries');
      const artefacts = localStorage.getItem(STORAGE_PREFIX + 'artefacts');
      
      if (entries) {
        state.entries = JSON.parse(entries);
      }
      if (artefacts) {
        state.artefacts = JSON.parse(artefacts);
      }
    }

    // ============================================
    // AUTH
    // ============================================
    function logoutUser() {
      localStorage.removeItem('jejak_username');
      localStorage.removeItem('jejak_user_id');
      localStorage.removeItem('jejak_logged_in');
      location.href = 'index.html';
    }

    // ============================================
    // INITIALIZATION
    // ============================================
    document.addEventListener('DOMContentLoaded', () => {
      // Update UI
      document.getElementById('header-username').textContent = state.currentUser;
      
      // Load saved data
      loadFromStorage();
      
      // Initialize systems
      initSupabase();
      loadFaceApiModels();
      initUploadSystem();
      
      // Render
      renderEntries();
      renderTray();
      updateQuotaDisplay();
      
      // Load from cloud
      if (state.isOnline) {
        loadUserRantsFromDB();
        loadUserArtefactsFromDB();
      }
      
      // Set initial hero
      const firstReal = state.artefacts.find(a => !a.isDummy);
      if (firstReal) {
        setHero(firstReal.url, firstReal.note, firstReal.faces);
      } else if (DUMMY_ARTEFACTS[0]) {
        setHero(DUMMY_ARTEFACTS[0].url, DUMMY_ARTEFACTS[0].note, DUMMY_ARTEFACTS[0].faces);
      }
      
      // Input listeners
      const rantInput = document.getElementById('rant-input');
      const charCount = document.getElementById('char-count');
      
      rantInput.addEventListener('input', () => {
        const len = rantInput.value.length;
        charCount.textContent = `${len}/500`;
        if (len >= 450) {
          charCount.style.color = 'var(--accent-tertiary)';
        } else {
          charCount.style.color = 'var(--text-muted)';
        }
      });
      
      // Submit handler
      document.getElementById('submit-btn').addEventListener('click', () => {
        const content = rantInput.value.trim();
        if (!content) {
          showToast('Tulis sesuatu dulu...');
          return;
        }
        submitRant(content, state.currentMood);
      });
      
      // Periodic quota update
      setInterval(updateQuotaDisplay, 60000);
    });
  </script>
</body>
</html>
